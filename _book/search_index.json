[["index.html", "מבוא לתכנות ב R 1 על הספר 1.1 איך לקרוא את הספר וההדרכות", " מבוא לתכנות ב R אופיר בצר 2021-10-18 1 על הספר בלה בלה בלה 1.1 איך לקרוא את הספר וההדרכות "],["מה-היא-שפת-r.html", " 2 מה היא שפת R? 2.1 יתרונות וחסרונות בשימוש ב R 2.2 מדריך התקנה", " 2 מה היא שפת R? בלה בלה בלה 2.1 יתרונות וחסרונות בשימוש ב R בלה בלה בלה 2.2 מדריך התקנה בלה בלה בלה "],["שימוש-ב-r-בתור-מחשבון.html", " 3 שימוש ב R בתור מחשבון 3.1 פעולות חשבון בסיסיות 3.2 קצת לינארית 3.3 דוגמא: נוסחת השורשים", " 3 שימוש ב R בתור מחשבון בלה בלה בלה 3.1 פעולות חשבון בסיסיות בלה בלה בלה 3.2 קצת לינארית בלה בלה בלה 3.3 דוגמא: נוסחת השורשים בלה בלה בלה "],["סוגי-משתנים-אבני-הבניין-שלנו.html", " 4 סוגי משתנים: אבני הבניין שלנו 4.1 משתנים?? 4.2 integer 4.3 numeric 4.4 logical 4.5 character", " 4 סוגי משתנים: אבני הבניין שלנו 4.1 משתנים?? יש מספר משפחות של שפות תכנות. אחת מהמשפחות הכי שחיכות נקראת ״תכנות מונחה עצמים״. למשל, השפות Java ו Python כתובות בסגנון של תכנות מונחה עצמיים, וכך גם R. לעניינו, לא חשוב לעומק מה המשמעות של הדבר הזה, אך כן חשוב לדעת שכל פונקציה, משתנה או אוביקט ב R יהיה שייך לאיזו מחלקה, שיש לה מאפיינים שיחודים לה. לדוגמא, אפשר לחבר אוביקט מספרי לאוביקט מספרי אחר, אך אין משמעות לחיבור של אוביקט מספרי ומחרוזת. כדי לברר לאיזה מחלקה כל אוביקט משוייך, אנחנו יכולים להשתמש בפונקציה class class(1) ## [1] &quot;numeric&quot; class(&quot;1&quot;) ## [1] &quot;character&quot; אכתוב עכשיו על סוגי המשתנים הבסיסים ביותר שיש בשפת R אשר ישמשו בתור אבני הבסיס של כל פרויקט שנרצה לבנות. intenger &amp; numeric: משתנים מספרים, ההבדל בין השתיים הוא יחס לשינויים אחרי הנקודה העשרונית logical: משתנה שמקבלים ערך של או אמת או שקר character: מילים או אותיות, אנחנו נקרא למשתנים כאלה ״מחרוזות״ 4.2 integer משנה זה יכיל ערכים של מספרים שלמים. הסיבה שיש הפרדה בין סוג המחלקה של מסרים שלמים ומספרים עם נקודה עשרונית, היא שניתן לשמור בזכרון של המחשב מספרים שלמים באופן יעיל יותר, לכן, אם האוביקט שלנו מכיל מספרים שלמים בלבד עדיף למחשב לשמור אותו כך. מספרים שלמים יכולים להיות מוצגים כך 5 או כך 5L. על מספרים שלמים אפשר לבצע פעולות חשבוניות, בדומה לאלו שהצגנו בפרק על שימוש ב R בתור מחשבון. אך יש לשים לב שאם נבצע פעולה שתשנה את וקטור המספרים השלמים שלנו למספרים שיש להם מקודה עשרונית - סוג המשתנה ישונה גם הוא v &lt;- c(1L, 9L, 9L, 6L) class(v) ## [1] &quot;integer&quot; print(v / 2) ## [1] 0.5 4.5 4.5 3.0 print(class(v / 2)) ## [1] &quot;numeric&quot; 4.3 numeric זה סוג המשתנה שכנראה תעבדו איתו הכי הרבה. על וקטורי numeric אפשר לעשות פעולות חשבוניות מגוונות, כפי שהדגמנו בפרק הקודם. 4.4 logical משתנים אלו מקבלים ערכים של אמת או של שקר. הם ישמשו אותנו הרבה פעמים בתור סוג של כפתור, או מתג, אשר יעזור לנו לחלק קבוצה לשתי קבוצות, ביחס לקיום של תנאי שנגדיר. שם נוסף שנשתמש בו למשתנים האלו יהיה משתנים בוליאנים. הערכים היחידם שמשתנים בוליאנים יכולים לקבל הם TRUE ו- FALSE 4.4.1 טבלאות אמת בלה בלה בלה 4.4.2 all all(c(T,T,T,F,T)) ## [1] FALSE all(c(T,T,T,T,T)) ## [1] TRUE 4.4.3 any any(c(F,T,F,F)) ## [1] TRUE any(c(F,F,F,F)) ## [1] FALSE 4.5 character בלה בלה בלה "],["תנאים.html", " 5 תנאים 5.1 יש! אנחנו יכולים לשאול את המחשב שאלות 5.2 וריאציות", " 5 תנאים לעיתים קרובות אנחנו רוצים לשאול את המחשב שאלות. למשל, נרצה לפעמים לקבל תובה של כן או לא על שאלות כמו האם המספר הזה זוגי? האם המחרוזת שלי באורך של 4 תווים? הדרך לעשות זאת בשפות תכנות באופן כללי, וגם בשפת R בפרט היא בעזרת שאילתות של if else. שאילתה כזאת תקבל איזה פסוק לוגי, שיכול לקבל ערך של או אמת או שקר, ואנו נפרט לה מה להחזיר עבור אמת ומה להחזיר עבור שקר. בואו נראה דוגמא. 5.1 יש! אנחנו יכולים לשאול את המחשב שאלות נניח ויש לי מספר, x, שמכיל רנדומלי ערך מסויים, נגיד 5. x &lt;- 5 אני יכול לבקש מהמחשב להדפיס האם הערך של x הוא זוגי או אי זוגי. ראשית אראה איך לכתוב את הפסוק הלוגי שיענה לי על השאלה הזאת. עבור כך אני אעשה שימוש באופרטור ״מודולו״ שכותבים אותו ב R כך %%. את הביטוי 11 %% 3 נקרא באופן הבא: 11 מודלו שלוש, והמשמעות המתמטית של הביטוי היא מהי שארית החלוקה במספרים שלמים של 11 חלקי 3. התשובה לכך היא 2. באופן תכנותי ב R אכתוב את השאלה הזאת כך 11 %% 3 ## [1] 2 מעולה! נחזור לעניינו, אני רוצה לברר האם המספר שלי x הוא זוגי או אי-זוגי. עבור כל מספר זוגי, שארית החלוקה ב 2 היא 0, ועבור כל מספר אי-זוגי שארית החלוקה ב 2 היא 1. לכך כדי לקבל תשובה של אמת או שקר על האם x הוא זוגי אכתוב ב R x %% 2 == 0 ## [1] FALSE זה התנאי ששאילתת ה ifelse שלנו תקבל. המבנה של שאילתת ifelse נראה כך: if(&quot;פסוק לוגי שיכול לקבל ערך של אמת או שקר&quot;){ &quot;פקודות של מה שיקרה אם הפסוק הוא פסוק אמת&quot; } else { &quot;פקודות של מה יקרה אם הפסוק הוא פסוק שקר&quot; } נראה דוגמא: if(x %% 2 == 0){ print(&quot;wow, x is even!&quot;) } else { print(&quot;look, x is odd!&quot;) } ## [1] &quot;look, x is odd!&quot; בגלל שערך של x הוא 5, x הוא אי-זוגי, התנאי בשאילתה קיבל ערך FALSE ולכן רצו רק הפקודות בתוך הסוגריים המסולסלים של ה else ולא רצו כלל הפקודות בתוך הסוגריים המסולסלים של ה if מגניב. 5.2 וריאציות ניתן לכלול יותר מתנאי אחד בשאילתת ifelse, למשל אני רוצה לחלק את הקלטים המספריים שלי באופן הבא: אם x זוגי וגדול מ 10, תדפיס ״ big-even\" אם x שווה בדיוק ל 1 תדפיס ״the one and only\" בכל מקרה אחר, תדפיס ״orrrr\" ב R הפקידה הזאת תראה כך: if(x %% 2 == 0 &amp; x &gt; 10){ print(&quot;big-even&quot;) } else if(x == 1){ print(&quot;the one and only&quot;) } else{ print(&quot;orrrr&quot;) } ## [1] &quot;orrrr&quot; באותה הדרך אנחנו יכולים להוסיף כמה תנאי שרק נראה, רק חשוב לשים לב שכותבים את הקוד בדיוק האותו האופן שכתבתי פה. 5.2.1 ifelse פקודה סופר שימושים ב R נקראת ifelse והיא משתמש ליצירת שאילתת תנאי על וקטור שלם. נניח שיש לי את הוקטור הרנדומלי הבא: rand_v &lt;- sample(1:100, 20) print(rand_v) ## [1] 49 67 99 35 26 38 77 70 17 78 20 71 94 45 31 58 47 6 14 84 ואני רוצה לשאול עבור כך ערך בנפרד האם הוא זוגי או אי-זוגי - אשתמש בשביל זה בפונקציה ifelse. הדרך לכתוב אותה היא כזאת: ifelse(&quot;מבחן על וקטור&quot; , &quot;מה להחזיר עם המבחן מצליח&quot;, &quot;מה להחזיר אם הוא לא מצליח&quot; ) ודוגמא לעניננו בפועל: ifelse(rand_v %% 2 == 0, &quot;good&quot;, &quot;why???&quot;) ## [1] &quot;why???&quot; &quot;why???&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; ## [7] &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; &quot;good&quot; &quot;why???&quot; ## [13] &quot;good&quot; &quot;why???&quot; &quot;why???&quot; &quot;good&quot; &quot;why???&quot; &quot;good&quot; ## [19] &quot;good&quot; &quot;good&quot; הפלט של הפונקציה הוא וקטור, ונוכל כמובן לשמור אותה לשימוש עתידי אם נרצה זאת. "],["לולאות.html", " 6 לולאות 6.1 for loops 6.2 while 6.3 apply", " 6 לולאות בלה בלה בלה 6.1 for loops בלה בלה בלה 6.2 while בלה בלה בלה 6.3 apply בלה בלה בלה "],["פונקציות.html", " 7 פונקציות 7.1 למה לכתוב פונקציות? 7.2 מגניב, איך עושים את זה? 7.3 כמה דוגמאות", " 7 פונקציות עד עכשיו יצא לנו להכיר פונקציות רבות ב base-r. בנוסף לפונקציות שהשתמשנו בהם, שאנשים אחרים תכנתו עבורונו, אנחנו יכולים לתכנת בעצמנו פונקציות שיעשו איזה משימה שנטיל עליהן! 7.1 למה לכתוב פונקציות? אם אנחנו מוצאים את עצמנו עושים את אותה הפעולה באופן חזרתי שוב ושוב, אנחנו סתם מבזבזים זמן בהקלדה מיותרת ומייגעת. בנוסף, הקוד החזרתי מקשה על הקריאה של הסקריפט שלנו. שימוש בפונקציות, שאותן נגדיר בראש הסקריפט שלנו, או בסקריפט אחר, יהפכו את הקוד שלנו ל״נקי״ ו״קריא״ יותר. 7.2 מגניב, איך עושים את זה? המבנה של כתיבת פונקציה נראה כך: name_of_my_function &lt;- function(input_1, ..., input_n){ code . . . code return(my_output) } כלומר, אנחנו מגדירים פונקציה בשם שאנחנו בוחרים, וקובעים שמות למשתנים שהפונקציה תקבל. לאחר מכן, בתוך הסוגריים המעוגלים, נעשה פעולות על הקלטים של הפונקציה, ונבסוף, נחזיר את מה שנרצה בתוך הפקודה return 7.3 כמה דוגמאות 7.3.1 דוגמא ראשונה - פונקציה שמקבלת משוואה רבועית, ומחזירה את שורשיה משוואה ריבועית היא משוואה מהצורה הזאת \\[ f(x) = a \\cdot x^2 + b \\cdot x + c \\] שורשים של משוואה כזאת מוגדרים להיות ערכי ה \\(x\\) אשר עבורם המשוואה שווה ל \\(0\\) . יש למשוואה רבועית נוסחא סגורה ומפורסת, שאני מניח שרובנו נתקלנו בה אי-אז בימי בית הספר העליזים. \\[ x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] כאשר \\(a, b, c\\) הם מקדמי המשוואה כפי שהגדרנו. אנחנו נכתוב עכשיו פונקציה פשוטה יחסית ב R שעבור כל משוואה ריבועית, תגיש לנו על מגש של כסף את פתרונותיה. התשובה תתקבל במהירות, והתוכנה תמיד תחזיר לנו תשובה נכונה, איזה כי, זה לתכנת, אה? אחלה. נתחיל. נקרא לפונציה שלנו sqrt_res, היא תקבל שלושה ערכים, שכולם יהיו מספרים, \\(a, b, c\\) אשר יתארו במדוייק את המשוואה הריבועית שעבורה אנחנו מעוניינים למצוא שורשים. הפלט שלה יהיה וקטור באורך 2. למשוואה רבועית יכולים להיות לכל היותר 2 פתרונות ממשיים, אך יישנן משוואות רבועיות שיש להן פתרון יחיד, או אפס פתרונות. במקרה הזה, הפונקציה שלנו תחזיר בוקטור ערכים חסרים sqrt_res &lt;- function(a, b, c){ if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } בואו נעשה שימוש בפונקציה שלנו! \\[ f(x) = x^2 \\] sqrt_res(a = 1, b = 0, c = 0) ## [1] 0 NA \\[ f(x) = x^2 + 3 \\] sqrt_res(a = 1, b = 0, c = 3) ## [1] NA NA \\[ f(x) = 2x^2 + 3x + 1 \\] sqrt_res(a = 2, b = 3, c = 1) ## [1] 0.2807764 -1.7807764 מגניב. יש לשים לב שאם הפונקציה שלנו היתה מקבלת קלטים לא רצויים, נניח מחרוזות במקום מספרים היא היתה ״נשברת״, כלומר לא עובדת כמו שרצינו שהיא תעבוד. ניתן להפוך את הפונקציה שלנו ל״חסינה״ לקלטים לא רצויים כך: sqrt_res &lt;- function(a, b, c){ if(class(c(a,b,c)) != &quot;numeric&quot;){ return(&quot;bad inputs!!!&quot;) } if((b**2 - 4*a*c) == 0){ return(c(-b/(2*a), NA)) } else if((b**2 - 4*a*c) &lt; 0){ return(c(NA, NA)) } else{ x_1 &lt;- (-b + (b**2 + 4*a*c)**0.5)/(2*a) x_2 &lt;- (-b - (b**2 + 4*a*c)**0.5)/(2*a) return(c(x_1, x_2)) } } נמשיך לדוגמא הבא. 7.3.2 דוגמא מספר 2 "],["ספריות.html", " 8 ספריות 8.1 למה להשתמש בספריות 8.2 איך להוריד ולטעון ספריות", " 8 ספריות בלה בלה בלה 8.1 למה להשתמש בספריות בלה בלה בלה 8.2 איך להוריד ולטעון ספריות בלה בלה בלה 8.2.1 base-r בלה בלה בלה 8.2.2 pacman בלה בלה בלה "]]
