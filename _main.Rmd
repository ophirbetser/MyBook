--- 
title: "מבוא לתכנות ב R"
author: "אופיר בצר"
date: "2021-10-18"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
# url: your book url like https://bookdown.org/yihui/bookdown
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::gitbook,
  set in the _output.yml file.
link-citations: yes
github-repo: ophirbetser/MyBook/index.html
---

# על הספר

הספר הזה נועד להיות מבוא בסיסי לתכנות בשפת
R
.
זהו אינו ספר העוסק בניתוח נתונים, ואין לקרוא אותו ככזה. בנוסף זהו אינו ספר אשר מומלץ ללמוד ממנו את אופן החשיבה הנרכש מקורסי מבוא למדעי המחשב. הספר מכוון לתת מבוא קצר, אך מעמיק מספיק לכלים תכנותים בסייסים, אשר בעזרתם ניתן ללמוד בהמשך נושאים תכנותיים מורכבים יותר. לדעתי יש יתרון בלהתחיל ללמוד קודם כל איך לכתוב קוד, אפילו לפני שלומדים כלים סטטיסטים הרלוונטים לניתוח הנתונים עצמו, כי יכולת התכנות הבסיסית עשויה להיות מאיימת ולא מזמינה, אך ברגע שמתחילים ״לשחק״ קצת עם הקוד, והנושא הופך לבהיר, מגלים כמה זה כיף, והתיאבון להמשך הלמידה גודל פלאים.

קריאה נעימה :)

## איך לקרוא את הספר וההדרכות 

את הספר אני ממליץ ללמוד פרק אחר פרק, ובמקביל לעבוד עם סקריפט 
R 
פתוח, ולנסות בעצמכם לממש ולייצר וריאציות של מה שמוצג. זוהי הדרך הטובה ביותר ללמוד, ולצבור ניסיון במגוון הדרכים השונות שאפשר לכתוב קוד.

בנוסף, עבור כל פרק בספר יצורף סרטון ווידאו שבו אעבור על החומר המוצג בספר. ניתן לצפות בסרטון במקביל לקריאה של הספר, עם זו דרך שבה אתם מעדיפים ללמוד.

## יצירת קשר

אם עולות שאלות, שמצאתם שגיאת כתיב או חוסר דיוק, אשמח לשמוע.
אפשר ליצור איתי קשר דרך כתובת המייל
ophir.betser@gmail.com

```{r include=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```


<!--chapter:end:index.Rmd-->

# מה היא שפת R? 

בלה בלה בלה

## יתרונות וחסרונות בשימוש ב R

בלה בלה בלה

## מדריך התקנה

בלה בלה בלה


<!--chapter:end:01-intro.Rmd-->

# שימוש ב R בתור מחשבון

בלה בלה בלה

## פעולות חשבון בסיסיות

```{r}
4 + 5
```

```{r}
4*5
```

```{r}
4 / 5
```

```{r}
4**5
```

```{r}
4**0.5
```

```{r}
sqrt(4)
```



```{r}
abs(-4)
```


```{r}
v <- c(2, 9, 0, 4, 1, 9, 9, 6)
```

```{r}
max(v)
```

```{r}
min(v)
```

```{r}
sort(v)
```




















## פונקציות סטיסטיות

### ממוצע

$$
\sum_{i=1}^n x_i = x_1 + x_2 + \dots + x_n
$$

$$
\bar x = \frac{1}{n} \sum_{i=1}^n x_i
$$

ממוצע של וקטור מוגדר להיות הסכום של כל איבר, חלקי אורך הוקטור.
בשפת 
R
הפונציה לחישוב כל סכום כל איברי וקטור היא 
`sum`

```{r}
v <- c(2, 9, 0, 4, 1, 9, 9, 6)
```

```{r}
print(v)
```

```{r}
sum(v)
```

והפונקציה לחישוב אורך של וקטור היא
`length`

```{r}
length(v)
```

לכן, על ידי שילוב שתי הפונקציות, נוכל לחשב מהו הממוצע של הוקטור

```{r}
sum(v) / length(v)
```

אך לא נצטרך לעשות זאת, כי ישנה פונקציה מובנת לחישוב הממוצע

```{r}
mean(v)
```

### שונות

$$
var(\vec x) = \sigma^2 = \frac{1}{n} \sum_{i = 1}^n (x_i - \bar x)^2
$$

שונות של וקטור מוגדרת להיות ממוצע סכומי המרחק מהממוצע בריבוע. נשמע מעט מורכב, אך ניתן לפרק את החישוב למספר פעולות פשוטות יותר, והמורכבות תעלם.

ראשית לשמור את הממוצע של 
v
בתור משתנה בשם 
v_bar

```{r}
v_bar <- mean(v)
```

לאחר מכן נחשב את וקטור המרחקים מהממוצע 

```{r}
v - v_bar
```

ונעלה את כל אחד מהמרחקים בריבוע

```{r}
(v - v_bar)**2
```

כעת, כל שנותר הוא לסכום את ריבועי המרחקים, ולחלק את הסכום באורך הוקטור

```{r}
sum((v - v_bar)**2) / length(v)
```

אך החישוב המיגע יכול היה להחסוך, כי גם לחישוב השונות קיימת פונקציה מובנת ב
R
 
```{r}
var(v)
```
 
### סטיית תקן

סטטית תקן מוגדרת להיות שורש השונות

$$
sd(\vec x) = \sigma_{\vec x} =
\sqrt{ \frac{1}{n} \sum_{i = 1}^n (x_i - \bar x)^2 } = 
\sqrt{var(\vec x)}
$$

### חציון

חציון מוגדר להיות הערך האמצעי בוקטור. כלומר הערך שמחציב מהערכים גדולים ממנו ומחציתם קטנים ממנו.
לכן, ניתן לכתוב עבור וקטור 
$\vec x$
מסודר בסדר עולה
בעל 
$n$
איברים
שהחציון שלו הוא האיבר המקיים:

$$
median(\vec x) = 
    \begin{cases}
      \frac{n}{2} & \text{if }\ n \text{ is even}\\
      \frac{n+1}{2} & \text{if }\ n \text{ is odd}\\
    \end{cases}
$$
נחשב זאת ב 
R
בעזרת הפונקציה 
`median`

```{r}
median(v)
```



## קצת לינארית

בלה בלה בלה

<!--chapter:end:02-simple_Math.Rmd-->

# סוגי משתנים: אבני הבניין שלנו

## משתנים??

יש מספר משפחות של שפות תכנות. אחת מהמשפחות הכי שחיכות נקראת ״תכנות מונחה עצמים״. למשל,
השפות 
Java
ו
Python
כתובות בסגנון של תכנות מונחה עצמיים, וכך גם 
R.

לעניינו, לא חשוב לעומק מה המשמעות של הדבר הזה, 
אך כן חשוב לדעת שכל פונקציה, משתנה או אוביקט ב
R 
יהיה שייך לאיזו מחלקה, שיש לה מאפיינים שיחודים לה.

<!-- TODO להוסיף קישור לסרטון שמסביר יותר על מה זה תכנות מונחה עצמים -->

לדוגמא, אפשר לחבר אוביקט מספרי לאוביקט מספרי אחר, אך אין משמעות לחיבור של אוביקט מספרי ומחרוזת. כדי לברר לאיזה
מחלקה כל אוביקט משוייך, אנחנו יכולים להשתמש בפונקציה 
`class`

```{r}
class(1)
```

```{r}
class("1")
```

אכתוב עכשיו על סוגי המשתנים הבסיסים ביותר שיש בשפת 
R
אשר ישמשו בתור אבני הבסיס של כל פרויקט שנרצה לבנות.


<li style="margin-left: 5px;">
**intenger & numeric:** משתנים מספרים, ההבדל בין השתיים הוא יחס לשינויים אחרי הנקודה העשרונית
</li>
<li style="margin-left: 5px;">
**logical:** משתנה שמקבלים ערך של או אמת או שקר
</li>
<li style="margin-left: 5px;">
**character:** מילים או אותיות, אנחנו נקרא למשתנים כאלה ״מחרוזות״
</li>

## integer

משנה זה יכיל ערכים של מספרים שלמים. הסיבה שיש הפרדה בין סוג המחלקה של מסרים שלמים ומספרים עם נקודה עשרונית, היא שניתן לשמור בזכרון של המחשב מספרים שלמים באופן יעיל יותר, לכן, אם האוביקט שלנו מכיל מספרים שלמים בלבד עדיף למחשב לשמור אותו כך. מספרים שלמים יכולים להיות מוצגים כך `5` או כך
`5L`.

על מספרים שלמים אפשר לבצע פעולות חשבוניות, בדומה לאלו שהצגנו בפרק על שימוש ב
R
בתור מחשבון.
אך יש לשים לב שאם נבצע פעולה שתשנה את וקטור המספרים השלמים שלנו למספרים שיש להם מקודה עשרונית - סוג המשתנה ישונה גם הוא

```{r}
v <- c(1L, 9L, 9L, 6L)
class(v)
```

```{r}
print(v / 2)
print(class(v / 2))
```




## numeric

זה סוג המשתנה שכנראה תעבדו איתו הכי הרבה. על וקטורי
numeric
אפשר לעשות פעולות חשבוניות מגוונות, כפי שהדגמנו בפרק הקודם.

## logical

משתנים אלו מקבלים ערכים של אמת או של שקר. הם ישמשו אותנו הרבה פעמים בתור סוג של כפתור, או מתג, אשר יעזור לנו לחלק קבוצה לשתי קבוצות, ביחס לקיום של תנאי שנגדיר.
שם נוסף שנשתמש בו למשתנים האלו יהיה משתנים בוליאנים.

הערכים היחידם שמשתנים בוליאנים יכולים לקבל הם
`TRUE`
ו- 
`FALSE`

### טבלאות אמת

בלה בלה בלה

### all

```{r}
all(c(T,T,T,F,T))
```

```{r}
all(c(T,T,T,T,T))
```


### any

```{r}
any(c(F,T,F,F))
```

```{r}
any(c(F,F,F,F))
```

## character

בלה בלה בלה


<!--chapter:end:03-variable_types.Rmd-->

# תנאים

לעיתים קרובות אנחנו רוצים לשאול את המחשב שאלות. למשל, נרצה לפעמים לקבל תובה של כן או לא על שאלות כמו האם המספר הזה זוגי? האם המחרוזת שלי באורך של 4 תווים?

הדרך לעשות זאת בשפות תכנות באופן כללי, וגם בשפת 
R
בפרט היא בעזרת שאילתות של 
if else.
שאילתה כזאת תקבל איזה פסוק לוגי, שיכול לקבל ערך של או אמת או שקר, ואנו נפרט לה מה להחזיר עבור אמת ומה להחזיר עבור שקר. בואו נראה דוגמא.

## יש! אנחנו יכולים לשאול את המחשב שאלות

נניח ויש לי מספר, 
x,
שמכיל רנדומלי ערך מסויים, נגיד 5.

```{r}
x <- 5
```

אני יכול לבקש מהמחשב להדפיס האם הערך של 
x
הוא זוגי או אי זוגי. ראשית אראה איך לכתוב את הפסוק הלוגי שיענה לי על השאלה הזאת. עבור כך אני אעשה שימוש באופרטור ״מודולו״ שכותבים אותו ב
R
כך
`%%`.
את הביטוי
`11 %% 3`
נקרא באופן הבא:
11 מודלו שלוש, 
והמשמעות המתמטית של הביטוי היא 
מהי שארית החלוקה במספרים שלמים של 11
חלקי 3.
התשובה לכך היא 2.

באופן תכנותי ב
R
אכתוב את השאלה הזאת כך

```{r}
11 %% 3
```

מעולה!
נחזור לעניינו, אני רוצה לברר האם המספר שלי 
x 
הוא זוגי או אי-זוגי.
עבור כל מספר זוגי, שארית החלוקה ב 2 היא 0,
ועבור כל מספר אי-זוגי שארית החלוקה ב 2 היא 1.

לכך כדי לקבל תשובה של אמת או שקר על האם 
x 
הוא זוגי אכתוב ב
R

```{r}
x %% 2 == 0
```

זה התנאי ששאילתת ה
ifelse
שלנו תקבל.

המבנה של שאילתת
ifelse
נראה כך:

```{r eval=FALSE, include=TRUE}
if("פסוק לוגי שיכול לקבל ערך של אמת או שקר"){
  "פקודות של מה שיקרה אם הפסוק הוא פסוק אמת"
} else {
  "פקודות של מה יקרה אם הפסוק הוא פסוק שקר"
}
```

נראה דוגמא:

```{r}
if(x %% 2 == 0){
  print("wow, x is even!")
} else {
  print("look, x is odd!")
}
```

 בגלל שערך של
 x
 הוא 5, 
 x
 הוא אי-זוגי,
 התנאי בשאילתה קיבל ערך 
 `FALSE`
 ולכן רצו רק הפקודות בתוך הסוגריים המסולסלים של ה
`else`
ולא רצו כלל הפקודות בתוך הסוגריים המסולסלים של ה
`if`

מגניב.

## וריאציות

ניתן לכלול יותר מתנאי אחד בשאילתת
ifelse, 
למשל אני רוצה לחלק את הקלטים המספריים שלי באופן הבא:

- אם x זוגי וגדול מ 10, תדפיס ״  big-even"
- אם x שווה בדיוק ל 1 תדפיס ״the one and only"
- בכל מקרה אחר, תדפיס ״orrrr"

ב
R
הפקידה הזאת תראה כך:

```{r}
if(x %% 2 == 0 & x > 10){
  print("big-even")
} else if(x == 1){
  print("the one and only")
} else{
  print("orrrr")
}
```

באותה הדרך אנחנו יכולים להוסיף כמה תנאי שרק נראה, רק חשוב לשים לב שכותבים את הקוד בדיוק האותו האופן שכתבתי פה.





### ifelse

פקודה סופר שימושים ב
R
נקראת 
`ifelse`
והיא משתמש ליצירת שאילתת תנאי על וקטור שלם.

נניח שיש לי את הוקטור הרנדומלי הבא:

```{r}
rand_v <- sample(1:100, 20)
print(rand_v)
```

ואני רוצה לשאול עבור כך ערך בנפרד האם הוא זוגי או אי-זוגי - אשתמש בשביל זה בפונקציה  
`ifelse`. הדרך לכתוב אותה היא כזאת:

```{r eval=FALSE, include=TRUE}
ifelse("מבחן על וקטור" ,
       "מה להחזיר עם המבחן מצליח",
       "מה להחזיר אם הוא לא מצליח"
       )
```

ודוגמא לעניננו בפועל:

```{r}
ifelse(rand_v %% 2 == 0,
       "good",
       "why???")
```


הפלט של הפונקציה הוא וקטור, ונוכל כמובן לשמור אותה לשימוש עתידי אם נרצה זאת.

 

<!--chapter:end:04-ifelse_conditions.Rmd-->

# לולאות

בשונה משפות תכנות רבות אחרות,
R
היא שפה וקטורית,
כלומר רוב הפעולות והפונקציות הבסיסיות בה מוכוונות לעבודה עם מערכים, או וקטורים מראש. העובדה ש
R
היא שפה וקטורית מורידה משמעותית את התלות שלנו בשימוש בלולאות, אך לעיתים עדיין אנו נרצה להשתמש בהם.

ללואות הן דרך לומר למחשב לבצע מספר רב של פעמיים פעולה דומה, ללא צורך בלכתוב קוד נפרד לכל פעולה. ישנם מספר סוגי לולאות, העיקריות הן לולאות 
`for`
אשר ישמשו אותנו לביצוע פעולה חזרתית מספר ידוע של פעמיים, 
ולולאות 
`while`
אשר יבצעו עוד ועוד חזרות, עד אשר תנאי שנגדיר יתקיים.

## for loops

```{r}
for(i in 1:10){
  print(i)
}
```


## while

```{r}
n <- 10
i <- 1
while(i < n){
  print(i)
  i <- i + 1
}
```


## apply

```{r}
matrix <- matrix(1:24, 6, 4)
matrix
```

```{r}
apply(matrix, 1, sum)
```

```{r}
apply(matrix, 2, sum)
```


<!--chapter:end:05-loops.Rmd-->

# פונקציות

עד עכשיו יצא לנו להכיר פונקציות רבות ב
base-r.
בנוסף לפונקציות שהשתמשנו בהם, שאנשים אחרים תכנתו עבורונו, אנחנו יכולים לתכנת בעצמנו פונקציות שיעשו איזה משימה שנטיל עליהן!

## למה לכתוב פונקציות?

אם אנחנו מוצאים את עצמנו עושים את אותה הפעולה באופן חזרתי שוב ושוב, אנחנו סתם מבזבזים זמן בהקלדה מיותרת ומייגעת. בנוסף, הקוד החזרתי מקשה על הקריאה של הסקריפט שלנו. שימוש בפונקציות, שאותן נגדיר בראש הסקריפט שלנו, או בסקריפט אחר, יהפכו את הקוד שלנו ל״נקי״ ו״קריא״ יותר.

## מגניב, איך עושים את זה?

המבנה של כתיבת פונקציה נראה כך:

```{r eval=FALSE, include=TRUE}
name_of_my_function <- function(input_1, ..., input_n){
  code
  .
  .
  .
  code
  return(my_output)
}
```

כלומר,
אנחנו מגדירים פונקציה בשם שאנחנו בוחרים, וקובעים שמות למשתנים שהפונקציה תקבל.
לאחר מכן, בתוך הסוגריים המעוגלים, נעשה פעולות על הקלטים של הפונקציה,
ונבסוף, נחזיר את מה שנרצה בתוך הפקודה
`return`


## כמה דוגמאות

### דוגמא ראשונה - פונקציה שמקבלת משוואה רבועית, ומחזירה את שורשיה

משוואה ריבועית היא משוואה מהצורה הזאת

$$
f(x) = a \cdot x^2 + b \cdot x + c
$$


שורשים של משוואה כזאת מוגדרים להיות ערכי ה
$x$
אשר עבורם המשוואה שווה ל
$0$
.

יש למשוואה רבועית נוסחא סגורה ומפורסת, שאני מניח שרובנו נתקלנו בה אי-אז בימי בית הספר העליזים.

$$
x_{1,2} = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a}
$$
כאשר 
$a, b, c$
הם מקדמי המשוואה כפי שהגדרנו.

אנחנו נכתוב עכשיו פונקציה פשוטה יחסית ב 
R
שעבור כל משוואה ריבועית, תגיש לנו על מגש של כסף את פתרונותיה.
התשובה תתקבל במהירות, והתוכנה תמיד תחזיר לנו תשובה נכונה, איזה כי, זה לתכנת, אה?

אחלה. נתחיל. נקרא לפונציה שלנו 
sqrt_res,
היא תקבל שלושה ערכים, שכולם יהיו מספרים,
$a, b, c$
אשר יתארו במדוייק את המשוואה הריבועית שעבורה אנחנו מעוניינים למצוא שורשים.
הפלט שלה יהיה וקטור באורך 2.
למשוואה רבועית יכולים להיות לכל היותר 2 פתרונות ממשיים, אך יישנן משוואות רבועיות שיש להן פתרון יחיד, או אפס פתרונות.
במקרה הזה, הפונקציה שלנו תחזיר בוקטור ערכים חסרים


```{r}
sqrt_res <- function(a, b, c){
  
  if((b**2 - 4*a*c) == 0){
    return(c(-b/(2*a), NA))
  } else if((b**2 - 4*a*c) < 0){
    return(c(NA, NA))
  } else{
    x_1 <- (-b + (b**2 + 4*a*c)**0.5)/(2*a)
    x_2 <- (-b - (b**2 + 4*a*c)**0.5)/(2*a)
    return(c(x_1, x_2))
  }
}
```

בואו נעשה שימוש בפונקציה שלנו!

$$
f(x) = x^2
$$

```{r}
sqrt_res(a = 1, b = 0, c = 0)
```

$$
f(x) = x^2 + 3
$$

```{r}
sqrt_res(a = 1, b = 0, c = 3)
```



$$
f(x) = 2x^2 + 3x + 1
$$

```{r}
sqrt_res(a = 2, b = 3, c = 1)
```


מגניב.
יש לשים לב שאם הפונקציה שלנו היתה מקבלת קלטים לא רצויים, נניח מחרוזות במקום מספרים היא היתה ״נשברת״, כלומר לא עובדת כמו שרצינו שהיא תעבוד. ניתן להפוך את הפונקציה שלנו ל״חסינה״ לקלטים לא רצויים כך:


```{r}
sqrt_res <- function(a, b, c){
  if(class(c(a,b,c)) != "numeric"){
    return("bad inputs!!!")
  }
  
  if((b**2 - 4*a*c) == 0){
    return(c(-b/(2*a), NA))
  } else if((b**2 - 4*a*c) < 0){
    return(c(NA, NA))
  } else{
    x_1 <- (-b + (b**2 + 4*a*c)**0.5)/(2*a)
    x_2 <- (-b - (b**2 + 4*a*c)**0.5)/(2*a)
    return(c(x_1, x_2))
  }
}
```


נמשיך לדוגמא הבא.

### דוגמא שניה








<!--chapter:end:06-functions.Rmd-->

# ספריות

ספריות, או באנגילת
packages
הן קבצים שאחנו יכולים להוריד וכך להוסיף פונקציות שימושיות לסביבת ה
R
שלנו, והרחיב את היקף הדברים שאנחנו יכולים לעשות בה.

שפת 
R
היא ״שפת קוד פתוח״
והמשמעות של זה היא שהתוכנה אינה שייכת לחברה מסחרית אחת, אלא היא נוצרה ומתוחזקת על ידי קהילת המשתמשים בה.
בתור אחת משפות התכנות הפופולאריות ביותר בעולם, יש ל
R
מיליוני משתמשים אשר תורמים לפיתוח שלה. כתיבת ספריות קוד היא אחת מהדרכים הכי שכיחות של תרומה כזאת. כל משתמש יכול לכתוב ספריה שתכיל את הפונקציות שלו, ולשתף אותן ברחבי האינטרנט למשתמשים אחרים. כך שהרבה פעמים, כאשר נמצא את עצמנו מעוניינים לבצע פעולה מסובכת, נגלה שמישהו כבר פתור אותה, כתב את הפתרון בתור פונקציה בספרייה, ושיתף אותה איתנו, וכל שנותר לנו הוא להוריד את הספריה למחשב שלנו.

## איך להוריד ולטעון ספריות

להוריד ספריות זה ממש קל!

## base-r

נניח ואני רוצה להוריד את הספריה 
`ggplot2` 
שהיא ספריה מדהימה ליצרית ויזואליזציות.

כל שעלי לעשות הוא להשתמש בפונקציה 
`install.packages`
ולהזין למה את שם הספריה שאני מעוניין להוריד בתור מרכאות

```{r eval=FALSE, include=TRUE}
install.packages("ggplot2")
```

הרצת שורת הקוד הזאת תפנה לדף האינטרנט שבו מאוחסן הקוד של הספריה, ותוריד אותו למחשב האישי שלכם.

כעת, בכל פעם שארצה להשתמש בספרייה הזאת, יהיו עלי להשתמש בפקודה 
`library`
שתקבל את שם הספריה שאותה אני רוצה לטעון, אך הפעם ללא מרכאות.


```{r eval=FALSE, include=TRUE}
library(ggplot2)
```

אפשר לחשוב על ההורדה של הספריה בתור קניית מצרכים מהסופר ואחסונם במזווה שלנו, ובטעינה של הספריה, הוצאה של המצרכים מהמזווה כדי להתחיל להכין איתם מנה מדהימה, או קוד אדיר!

## מבט על כל הפונקציות שיש בכל ספריה

כדי לראות את כל הפונקציות שכל ספריה מציעה,
נרשום את שם הספריה, ונוסיף
`::`
ואז תופיע לנו רשימה של הפונקציות שהספריה מכילה

![](07-packages_insertimage_1.png)


## pacman

דרך מעט נוחה יותר בעיני לעשות זאת היא להשתמש במנהל ספריות. הספריה של 
R
`pacman`
תאפשר לנו להוריד ולטעון ספריות בפקודה אחת, ובאופן יותר קריא.

נתחיל קודם כל בלהוריד את הספריה

```{r eval=FALSE, include=TRUE}
install.packages("pacman")
```

כעת, נעשה שימוש בפקודה
`p_load`
כדי להוריד ולטעון את הספריות שאנחנו מעוניינים בהם. אם ספריה הורדה בעבר למחשב שלנו, 
pacman 
רק תטען אותה, 
ואם היא אינה הורדה בעבר למחשב שלנו
היא גם תורד וגם תטען בפקודה אחת

```{r eval=FALSE, include=TRUE}
pacman::p_load(
  ggplot2,
  data.table,
  DT,
  lubridate
)
```








<!--chapter:end:07-packages.Rmd-->

